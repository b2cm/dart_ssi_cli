import 'package:dart_ssi/credentials.dart';
import 'package:dart_ssi/didcomm.dart';
import 'package:dart_ssi/wallet.dart';
import 'package:ssi_cli/src/constants.dart';
import 'package:ssi_cli/src/services/cli_service.dart';
import 'package:ssi_cli/src/services/didcomm/didcomm_service.dart';

import '../../services/didcomm/oob_service.dart';
import '../ssi_cli_base.dart';


class DidCommProposeCredential extends SsiCliCommandBase {

  @override
  final name = COMMAND_DIDCOMM_PROPOSE_CREDENTIAL;

  @override
  final description =
      "Proposing a credential to the Server "
      "(likely generated by an OOB Credential offer)";

  DidCommProposeCredential() {
    addWalletNecessaryParametersToArgParser(argParser);

    argParser
      ..addOption(PARAM_REPLY_URL,
        help: "Reply URL to send the response to",
        valueHelp: '"https://example.com/didcomm/receive"')

      ..addOption(
        PARAM_CONNECTION_DID,
        valueHelp: '"did:ethr:0xF1..."',
        help: "DID: Connection DID you want to use to answer. Must be "
            "controlled by the wallet.",
        mandatory: true)

      ..addOption(PARAM_CREDENTIAL_DID,
        valueHelp: '"did:ethr:0xF1..."',
        help: "DID: Credential DID you want to relate the credential with. "
            "Must be controlled by the wallet",
        mandatory: true)

      ..addOption(PARAM_DIDCOMM_OOB_INVITATION,
        help: "JSON or base64 url-encoded string: the OOB Invitation which has to have the credential offer "
              "within its attachments",
        mandatory: true);
    ;
  }

  @override
  run() async {
    Map<String, dynamic> invitation = getArgJson(PARAM_DIDCOMM_OOB_INVITATION)!;
    var replyUrl = getArgString(PARAM_REPLY_URL)!;
    var connectionDid = getArgDid(PARAM_CONNECTION_DID)!;
    var credentialDid = getArgDid(PARAM_CONNECTION_DID)!;
    var walletName = getArgString(PARAM_WALLET_NAME)!;

    var wallet = await loadWalletFromArgs();
    if (!wallet
        .getAllConnections()
        .keys
        .contains(connectionDid)) {
      writeError("Connection DID `$connectionDid` "
          "not found in wallet `$walletName`", 345345983);
    }

    if (!wallet
        .getAllCredentials()
        .keys
        .contains(credentialDid)) {
      writeError("Credential DID `$credentialDid` "
          "not found in wallet `$walletName`", 43590834890);
    }

    late OutOfBandMessage oob;
    try {
      oob = OutOfBandMessage.fromJson(invitation);
    } catch (e) {
      writeError("Could not parse OOB Invitation due to `{$e}`", 4359834905);
    }

    late DidcommPlaintextMessage attachment;
    try {
      attachment = (await getPlaintextFromOobAttachments(oob)).firstWhere((
          element) => element.isOk).unrwap();
    } catch (e) {
      writeError("Could resolve any OOB Attachment `${e.toString()}`", 230948239048);
    }

    late OfferCredential offer;
    try {
      offer = OfferCredential.fromJson(attachment.toJson());
    } catch (e) {
      writeError("Could not parse Credential offer due to `$e`", 234234);
    }
    var proposal = await generateProposeCredential(
        offer: offer,
        wallet: wallet,
        connectionDid: connectionDid,
        replyUrl: replyUrl,
        credentialDid: credentialDid);

    var msg = await encryptMessage(connectionDid: connectionDid, message: proposal,
        wallet: wallet, receiverDid: credentialDid);

    writeResultJson(msg.toJson());
  }
}

Future<ProposeCredential> generateProposeCredential({
  required OfferCredential offer,
  required WalletStore wallet,
  required String connectionDid,
  required String replyUrl,
  required String credentialDid,
}
) async {
  print('Meine credential did: $credentialDid');
  var offeredCred = offer.detail!.first.credential;
  var credSubject = offeredCred.credentialSubject;
  credSubject['id'] = credentialDid;
  var newCred = VerifiableCredential(
      id: credentialDid,
      context: offeredCred.context,
      type: offeredCred.type,
      issuer: offeredCred.issuer,
      credentialSubject: credSubject,
      issuanceDate: offeredCred.issuanceDate,
      credentialSchema: offeredCred.credentialSchema,
      expirationDate: offeredCred.expirationDate);

  print(newCred);

  var message = ProposeCredential(
      threadId: offer.threadId ?? offer.id,
      from: connectionDid,
      to: [offer.from!],
      replyUrl: replyUrl,
      detail: [
        LdProofVcDetail(
            credential: newCred, options: offer.detail!.first.options)
      ]);

  //Sign attachment with credentialDid
  for (var a in message.attachments!) {
    await a.data.sign(wallet, credentialDid);
  }

  return message;
}
